# Session 5: PydanticAI Type-Safe Agents
## Modern Python Agent Development with Type Safety

### ðŸŽ¯ **Session Overview**
PydanticAI leverages modern Python features and Pydantic's type system to create agents with structured outputs, validation, and type safety. This session explores building robust, maintainable agents using contemporary Python best practices.

### ðŸ“š **Learning Objectives**
1. **Master PydanticAI architecture** and type-safe agent patterns
2. **Implement structured outputs** with automatic validation
3. **Build type-safe tools** and function calling interfaces
4. **Create robust error handling** with Pydantic validation
5. **Design maintainable agents** using modern Python practices

---

## **PydanticAI Architecture**

### **Type-Safe Agent Definition**
```python
# src/session5/pydantic_agents.py
from pydantic_ai import Agent, RunContext
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

# Structured output models
class ResearchResult(BaseModel):
    """Type-safe research result structure"""
    topic: str = Field(description="Research topic")
    key_findings: List[str] = Field(description="Main research findings")
    confidence_score: float = Field(ge=0.0, le=1.0, description="Confidence in findings")
    sources: List[str] = Field(description="Information sources")
    timestamp: datetime = Field(default_factory=datetime.now)

class AnalysisRequest(BaseModel):
    """Input validation for analysis requests"""
    data: List[float] = Field(min_items=1, description="Data to analyze")
    analysis_type: str = Field(regex=r'^(mean|median|trend)$')
    confidence_level: Optional[float] = Field(default=0.95, ge=0.5, le=0.99)

# Type-safe agent
research_agent = Agent(
    'openai:gpt-4',
    result_type=ResearchResult,
    system_prompt="You are a research analyst. Provide structured research results."
)

@research_agent.tool
def web_search(ctx: RunContext[str], query: str) -> str:
    """Search the web for information"""
    # Type-safe tool implementation
    return f"Search results for: {query}"

@research_agent.tool  
def calculate_stats(ctx: RunContext[AnalysisRequest], request: AnalysisRequest) -> dict:
    """Calculate statistics with input validation"""
    import statistics
    
    data = request.data
    if request.analysis_type == "mean":
        return {"result": statistics.mean(data), "type": "mean"}
    elif request.analysis_type == "median":
        return {"result": statistics.median(data), "type": "median"}
    # Additional analysis types...
```


### **Advanced Type-Safe Patterns**
```python
# Multi-step workflow with validation
class WorkflowStep(BaseModel):
    step_name: str
    input_data: dict
    output_data: Optional[dict] = None
    success: bool = False
    error_message: Optional[str] = None

class WorkflowResult(BaseModel):
    workflow_id: str
    steps: List[WorkflowStep]
    overall_success: bool
    execution_time: float

# Type-safe multi-step agent
workflow_agent = Agent(
    'openai:gpt-4',
    result_type=WorkflowResult,
    system_prompt="Execute multi-step workflows with validation"
)

@workflow_agent.tool_plain
def validate_and_execute_step(step_config: dict) -> WorkflowStep:
    """Execute workflow step with validation"""
    try:
        step = WorkflowStep(**step_config)
        # Execute step logic
        step.output_data = {"processed": True}
        step.success = True
        return step
    except Exception as e:
        return WorkflowStep(
            step_name=step_config.get("step_name", "unknown"),
            input_data=step_config,
            success=False,
            error_message=str(e)
        )
```


---

## **Self-Assessment Questions**

1. What is the primary benefit of PydanticAI's type-safe approach?
   a) Better performance
   b) Automatic validation and structured outputs
   c) Lower resource usage  
   d) Simpler syntax

2. How does PydanticAI handle input validation?
   a) Manual validation in code
   b) Automatic validation using Pydantic models
   c) No validation provided
   d) External validation services

3. What happens when a PydanticAI tool receives invalid input?
   a) Silent failure
   b) Automatic error handling with validation errors
   c) System crash
   d) Default value substitution

**Answer Key**: 1-b, 2-b, 3-b

---

## **Key Takeaways**
1. **Type safety reduces runtime errors** and improves code reliability
2. **Structured outputs** enable consistent data handling and validation
3. **Pydantic integration** provides automatic validation and serialization
4. **Modern Python practices** improve code maintainability

## **Next Steps**
Session 6 integrates existing ADK materials for enterprise agent development.

---

*This session demonstrated PydanticAI's type-safe approach to building robust, maintainable agents.*